# 学习笔记



1.写出[不同路径 2 ](https://leetcode-cn.com/problems/unique-paths-ii/)这道题目的状态转移方程

> ###  1、状态定义：
>
> `dp[i][j]` 表示走到格子 `(i, j)` 的方法数
>
> ### 2、状态转移：
>
> 如果网格 `(i, j)` 上有障碍物，则 `dp[i][j]`  值为 0，表示走到该格子的方法数为 0；
> 否则网格 `(i, j)` 可以从网格 `(i - 1, j)` 或者 网格 `(i, j - 1)` 走过来，因此走到该格子的方法数为走到网格 `(i - 1, j)` 和网格 `(i, j - 1)` 的方法数之和，即 `dp[i, j] = dp[i - 1, j] + dp[i, j - 1]`。
>
> 状态转移方程如下：
>
> $$dp[i][j]=
> \begin{cases}
> dp[i−1,j]+dp[i,j−1]& \text{(i,j)上无障碍物}\\
> 0& \text{(i,j)上有障碍物}
> \end{cases}$$
>
> ### 3、初始条件
>
> 第 1 列的格子只有从其上边格子走过去这一种走法，因此初始化 `dp[i][0]` 值为 1，存在障碍物时为 0；
>
> 第 1 行的格子只有从其左边格子走过去这一种走法，因此初始化 `dp[0][j]` 值为 1，存在障碍物时为 0。
>



## 高级动态规划

### 关键点

1. 动态规划 和 递归或者分治 没有根本上的区别（关键看有无最优的子结构）
2. 拥有共性：找到重复子问题
3. 差异性：最优子结构、中途可以淘汰次优解



### 高阶的 DP 问题

1. 状态拥有更多维度（二维、三维、或者更多、甚至需要压缩）
2. 状态方程更加复杂





## 字符串

### Rabin-Karp 算法

> 在朴素算法中，我们需要挨个比较所有字符，才知道目标字符串中是否包含
> 子串。那么， 是否有别的方法可以用来判断目标字符串是否包含子串呢？
>
> 答案是肯定的，确实存在一种更快的方法。为了避免挨个字符对目标字符串
> 和子串进行比较， 我们可以尝试一次性判断两者是否相等。因此，我们需
> 要一个好的哈希函数（hash function）。 通过哈希函数，我们可以算出子
> 串的哈希值，然后将它和目标字符串中的子串的哈希值进行比较。 这个新
> 方法在速度上比暴力法有显著提升。

Rabin-Karp 算法的思想：

1. 假设子串的长度为 M (pat)，目标字符串的长度为 N (txt)

2. 计算子串的 hash 值 hash_pat

3. 计算目标字符串txt中每个长度为 M 的子串的 hash 值（共需要计算 N-M+1
次）

4. 比较 hash 值：如果 hash 值不同，字符串必然不匹配; 如果 hash 值相同，
还需要使用朴素算法再次判断



### KMP 算法

> KMP算法（Knuth-Morris-Pratt）的思想就是，当子串与目标字符串不匹配时，
> 其实你已经知道了前面已经匹配成功那 一部分的字符（包括子串与目标字符
> 串）。以阮一峰的文章为例，当空格与 D 不匹配时，你其实 知道前面六个字符是
> “ABCDAB”。KMP 算法的想法是，设法利用这个已知信息，不要把“搜索位
> 置” 移回已经比较过的位置，继续把它向后移，这样就提高了效率。
>
> https://www.bilibili.com/video/av11866460?from=search&seid=17425875345653862171
> http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html